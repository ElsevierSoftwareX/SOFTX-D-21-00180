<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: TA_BPMN_editor/app/temporal-modeler/temporal-plugins-client/CSTNU/cstnuChecked.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: TA_BPMN_editor/app/temporal-modeler/temporal-plugins-client/CSTNU/cstnuChecked.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
/**@module  temporal-plugins-client/CSTNU/cstnuChecked
 * @description
 * In the process of verification of the CSTNU, an updated CSTNU is generated 
 * if the consistency of the network is True. This module reads the updated network 
 * and updates the temporal properties of the elements in the BPMN diagram. 
 */

 import extHelper from "bpmn-js-properties-panel/lib/helper/ExtensionElementsHelper";


export default function cstnuChecked(xmlCTNUChecked, myObjs) {

  let parser = new DOMParser();
  let xmlCSTNU_Doc = parser.parseFromString(xmlCTNUChecked, "text/xml");
  const modeling = window.bpmnjs.get('modeling');
  const elementRegistry = window.bpmnjs.get('elementRegistry');
  let elementsUpdated = [];

  let currentBPMN_Obj;

  // Update elements --> NO contingents 
  let tmpElement; 

  let contingentElements = ["UserTask", "ServiceTask", "SendTask", "ReceiveTask", "SubProcess",
    "TimerEventDefinition", "MessageEventDefinition", "SignalEventDefinition"];
  let noContingentElements = ["ScripTask", "SequenceFlow", "ParallelGateway", "ExclusiveGateway", "EventBasedGateway"];
  let noConsideredElements = ["Task"];

  let myKeys = Object.keys(myObjs);
  for (let k = 0; k &lt; myKeys.length; k++) {
    currentBPMN_Obj = myObjs[myKeys[k]];

    if (currentBPMN_Obj.cstnuEdgeIds &amp;&amp; currentBPMN_Obj.edgeType === 'normal') {
      for (let i = 0; i &lt; currentBPMN_Obj.cstnuEdgeIds.length; i++) {

        let edge = xmlCSTNU_Doc.getElementById(currentBPMN_Obj.cstnuEdgeIds[i]);
        for (let j = 0; j &lt; edge.children.length; j++) {
          let labeled = edge.children[j];
          if (labeled.attributes.key.value === 'LabeledValues') {

            let newLabel = labeled.textContent;
            let newValue = newLabel.split(',')[0].split('(').slice(-1)[0];

            if (currentBPMN_Obj.cstnuEdgeIds[i][0] === 'S') { //Update max value
              tmpElement = elementRegistry.get(currentBPMN_Obj.id);
              let maxDurationTmp = getExtensionElementValue(tmpElement, "TDuration", "maxDuration")
              // if (tmpElement.businessObject.maxDuration &amp;&amp; tmpElement.businessObject.maxDuration != newValue) {
              if (maxDurationTmp &amp;&amp; maxDurationTmp != newValue) {
                window.elementsUpdated.push(currentBPMN_Obj.id);
                modeling.updateProperties(tmpElement, {
                  // maxDuration: newValue,
                  updated: true
                });
                setExtensionElementValue(tmpElement, "TDuration", "maxDuration", newValue);
                elementsUpdated.push(currentBPMN_Obj.id);
              }

            }
            else if (currentBPMN_Obj.cstnuEdgeIds[i][0] === 'E') { //Update min value
              tmpElement = elementRegistry.get(currentBPMN_Obj.id);

              if (Number(newValue) != 0) newValue = -Number(newValue);

              let minDurationTmp = getExtensionElementValue(tmpElement, "TDuration", "minDuration")
              
              // if (tmpElement.businessObject.minDuration &amp;&amp; tmpElement.businessObject.minDuration != newValue) {
                if (minDurationTmp &amp;&amp; minDurationTmp != newValue) {
                window.elementsUpdated.push(currentBPMN_Obj.id);
                modeling.updateProperties(tmpElement, {
                  // minDuration: newValue,
                  updated: true
                });
                setExtensionElementValue(tmpElement, "TDuration", "minDuration", newValue);

                elementsUpdated.push(currentBPMN_Obj.id);
              }
            }
            else {
              console.log('No updated ' + currentBPMN_Obj.id + ' ' + currentBPMN_Obj.cstnuEdgeIds);
            }
          }

        }

      }

    }
    currentBPMN_Obj = undefined;
  }

  // Update arrows
  myKeys = Object.keys(myObjs.arrows);
  for (let k = 0; k &lt; myKeys.length; k++) {
    currentBPMN_Obj = myObjs.arrows[myKeys[k]];
    

    if (currentBPMN_Obj.cstnuEdgeIds &amp;&amp; currentBPMN_Obj.edgeType === 'normal') {
      for (let i = 0; i &lt; currentBPMN_Obj.cstnuEdgeIds.length; i++) {

        let edge = xmlCSTNU_Doc.getElementById(currentBPMN_Obj.cstnuEdgeIds[i]);
        for (let j = 0; j &lt; edge.children.length; j++) {
          let labeled = edge.children[j];
          if (labeled.attributes.key.value === 'LabeledValues') {

            let newLabel = labeled.textContent;
            let newValue = newLabel.split(',')[0].split('(').slice(-1)[0];

            if (currentBPMN_Obj.cstnuEdgeIds[i][0] === 'E') { //Update max value
              tmpElement = elementRegistry.get(currentBPMN_Obj.id);
              let maxDurationTmp = getExtensionElementValue(tmpElement, "TDuration", "maxDuration")


              // if (tmpElement.businessObject.maxDuration &amp;&amp; tmpElement.businessObject.maxDuration != newValue) {
                if (maxDurationTmp &amp;&amp; maxDurationTmp != newValue) {
                window.elementsUpdated.push(currentBPMN_Obj.id);
                modeling.updateProperties(tmpElement, {
                  // maxDuration: newValue,
                  updated: true
                });
                setExtensionElementValue(tmpElement, "TDuration", "maxDuration", newValue);
                elementsUpdated.push(currentBPMN_Obj.id);
              }
            }
            else if (currentBPMN_Obj.cstnuEdgeIds[i][0] === 'S') { //Update min value
              tmpElement = elementRegistry.get(currentBPMN_Obj.id);
              if (Number(newValue) != 0) newValue = -Number(newValue);
              
              let minDurationTmp = getExtensionElementValue(tmpElement, "TDuration", "minDuration")

              // if (tmpElement.businessObject.minDuration &amp;&amp; tmpElement.businessObject.minDuration != newValue) {
              if (minDurationTmp &amp;&amp; minDurationTmp != newValue) {
                
                window.elementsUpdated.push(currentBPMN_Obj.id);
                modeling.updateProperties(tmpElement, {
                  // minDuration: newValue,
                  updated: true
                });
                modeling.up
                setExtensionElementValue(tmpElement, "TDuration", "minDuration", newValue);
                elementsUpdated.push(currentBPMN_Obj.id);
              }
            }
            else {
              console.log('No updated ' + currentBPMN_Obj.id + ' ' + currentBPMN_Obj.cstnuEdgeIds);
            }
          }
        }
      }
    }
    currentBPMN_Obj = undefined;
  }
  return elementsUpdated;
}



function getExtensionElementValue(element, typeName, property) {  
  let extensions = extHelper.getExtensionElements(
    element.businessObject,
    "tempcon:" + typeName
  );
  let returnValue;
  if (extensions) {
    if (extensions.length>0){
      returnValue = extensions[0][property];
    }  
  } 
  
  // console.log('Return ' + property + ' ' + returnValue );
  return returnValue;

}


function setExtensionElementValue(element, typeName, property, value) {
  
  const moddle = window.bpmnjs.get('moddle');
  const eventBus = window.bpmnjs.get('eventBus');
  const modeling = window.bpmnjs.get('modeling');


  let prefixTypeElement = "tempcon:" + typeName;


  const extensionElements = element.businessObject.extensionElements || moddle.create('bpmn:ExtensionElements');
  let analysisDetails = getExtensionElement(element.businessObject, prefixTypeElement);

  if (!analysisDetails) {
    analysisDetails = moddle.create(prefixTypeElement);
  
    extensionElements.get('values').push(analysisDetails);
  }

  analysisDetails[property] = value;
  modeling.updateProperties(element, {
        extensionElements
      });
  
}

function getExtensionElement(element, type) {
  if (!element.extensionElements) {
    return;
  }

  return element.extensionElements.values.filter((extensionElement) => {
    return extensionElement.$instanceOf(type);
  })[0];
}

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">TimeAwareBPMN-js</a></h2><h3>Modules</h3><ul><li><a href="module-serverNodeJs.html">serverNodeJs</a></li><li><a href="module-temporal-plugins-client.html">temporal-plugins-client</a></li><li><a href="module-temporal-plugins-client_CSTNU.html">temporal-plugins-client/CSTNU</a></li><li><a href="module-temporal-plugins-client_CSTNU_bpmn2cstnu.html">temporal-plugins-client/CSTNU/bpmn2cstnu</a></li><li><a href="module-temporal-plugins-client_CSTNU_bpmnSetcstnuLabels.html">temporal-plugins-client/CSTNU/bpmnSetcstnuLabels</a></li><li><a href="module-temporal-plugins-client_CSTNU_cstnuChecked.html">temporal-plugins-client/CSTNU/cstnuChecked</a></li><li><a href="module-temporal-plugins-server.html">temporal-plugins-server</a></li><li><a href="module-temporal-plugins-server_CSTNU.html">temporal-plugins-server/CSTNU</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-TA_BPMN_editor.html">TimeAwareBPMN-editor</a></li><li><a href="tutorial-index_.html">TimeAwareBPMN-js</a></li><li><a href="tutorial-temporal-plugins-client.html">Client-side plug-in</a></li><li><a href="tutorial-temporal-plugins-server.html">Server-side plug-in</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sun Sep 26 2021 19:43:03 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
