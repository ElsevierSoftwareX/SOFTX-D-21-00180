<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: BPMNio_TC_Modeler/app/temporal-modeler/temporal-plugins-client/CSTNU/bpmn2cstnu.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: BPMNio_TC_Modeler/app/temporal-modeler/temporal-plugins-client/CSTNU/bpmn2cstnu.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**@module  temporal-plugins-client/CSTNU/bpmn2cstnu
 * @description
 * Performs the translation of a XML string of the BPMN model to CSTNU XML string.
 */

const builder = require("xmlbuilder");

/** @function bpmn2cstnu
 * Main function of the module.
 * @param {*} bpmn 
 * @param {*} customElements 
 * @param {*} fileName 
 * @returns {Object} { xmlString, myLogObj, countObjs, myObjs, textMessage }
 */
export default function bpmn2cstnu(bpmn, customElements, fileName) {

  let parser = new DOMParser();
  let xmlDoc = parser.parseFromString(bpmn, "text/xml");

  // The nodes are elements (keys) in the dictionary, 
  // the edges will be stores in the element (key) arrows
  let myObjs = {};
  myObjs['intertask'] = { datainput: [], dataoutput: [] }; // To recover the connections 
  myObjs['edges_ids'] = {};  // To avoid duplicated ids
  myObjs['arrows'] = {};  // To create the graph 
  myObjs['nodeObservation'] = ['P', 'Q', 'R', 'S', 'T', 'U', 'V',];  // pLabels 
  // To keep track of errors and show them to the user
  let myLogObj = { log: "", errors: "", warnings: "" };

  let countObjs = {
    tasks: 0,
    nodes: 0,
    edges: 0,
    nContingents: 0,
    nObservedProposition: 0,
    elementsWithError: 0,
    elementsWithWarning: 0,
    startEventsTotal: 0,
    startEvents: 0,
    endEvents: 0,
    endEventsTotal: 0
  };

  let root = getStart_xml();
  let graph = root.ele("graph", { edgedefault: "directed" });
  let bpmnPlane = get_bpmnPlane(xmlDoc);
  let processName = fileName; // getProcessName(xmlDoc);

  setElements(xmlDoc, bpmnPlane, graph, myLogObj, countObjs, myObjs, customElements);

  // Elements with global information, to compute at the end.
  graph.ele("data", { key: "nContingent" }, countObjs.nContingents);
  graph.ele("data", { key: "nObservedProposition" }, countObjs.nObservedProposition);
  graph.ele("data", { key: "NetworkType" }, "CSTNU");
  graph.ele("data", { key: "nEdges" }, countObjs.edges);
  graph.ele("data", { key: "nVertices" }, countObjs.nodes);
  graph.ele("data", { key: "Name" }, processName);

  // let xmlString = root.end();
  let xmlString = root.end({
    pretty: true,
    indent: "  ",
    newline: "\n",
    width: 0,
    allowEmpty: false,
    spacebeforeslash: "",
  });

  myLogObj.errors = 'Elements with error: ' + countObjs.elementsWithError + '\n' + myLogObj.errors;
  myLogObj.warnings = 'Elements with warning: ' + countObjs.elementsWithWarning + '\n' + myLogObj.warnings;

  let textMessage = '';
  if (countObjs.elementsWithError > 0)
    textMessage += '\n' + myLogObj.errors;
  textMessage += '\n' + 'Warnings: ' + countObjs.elementsWithWarning;
  if (countObjs.elementsWithWarning > 0)
    divModalContent.innerText += '\n' + myLogObj.warnings;

  return { xmlString, myLogObj, countObjs, myObjs, textMessage };
}

/**
 * Check range of [minDuration, maxDuration] of the elements 
 * @param {xmlNode} element XML node with min and max duration
 * @param {Object} logObj Object with log and errors
 * @param {string} edgeType Contingent or normal
 * @returns {Object} minDuration, maxDuration, okVals
 */
function checkMinMax(element, logObj, edgeType) {
  let minDuration = undefined, maxDuration = undefined, okVals = true;
  let currentErrors = '';
  let nodeName = element.nodeName + ' ';
  if (element.attributes.name != undefined) nodeName += element.attributes.name.value.replace(/(\r\n|\n|\r)/gm, " ") + ' ';
  if (element.attributes.id != undefined) nodeName += '\n[' + element.attributes.id.value + '] ';
  logObj.log += "\n " + nodeName + " ";

  if (element.attributes["cstnu:minDuration"] === undefined) {
    currentErrors += '\n\tminDuration undefined';
    okVals = false;
  }
  if (element.attributes["cstnu:maxDuration"] === undefined) {
    currentErrors += '\n\tmaxDuration undefined';
    okVals = false;
  }

  if (okVals) {
    minDuration = element.attributes["cstnu:minDuration"].value;
    maxDuration = element.attributes["cstnu:maxDuration"].value;

    if (minDuration === undefined) {
      currentErrors += "\n\tminDuration undefined ";
      okVals = false;
    }
    else if (isNaN(minDuration)) {
      currentErrors += "\n\tminDuration (" + minDuration + ") is NaN ";
      okVals = false;
    }
    else if (!Number.isInteger(parseFloat(minDuration))) {
      currentErrors += "\n\tminDuration (" + minDuration + ") is not integer ";
      okVals = false;
    }
    else if (edgeType === "contingent" &amp;&amp; Number(minDuration) &lt;= 0) {
      currentErrors += "\n\tminDuration (" + minDuration + ") should be > 0 ";
      okVals = false;
    }
    else if (edgeType === "normal" &amp;&amp; Number(minDuration) &lt; 0) {
      currentErrors += "\n\tminDuration (" + minDuration + ") should be >= 0 ";
      okVals = false;
    }
    else if (edgeType != "normal" &amp;&amp; edgeType != "contingent") {
      currentErrors += "\n\tunknown edgeType (" + edgeType + ")";
      okVals = false;
    }
    else logObj.log += "\n " + nodeName + " minDuration " + minDuration + " ";

    if (maxDuration === undefined) {
      currentErrors += "\n\tmaxDuration undefined ";
      okVals = false;
    }
    else if (isNaN(maxDuration)) {
      currentErrors += "\n\tmaxDuration (" + maxDuration + ") is NaN ";
      okVals = false;
    }
    else if (!Number.isInteger(parseFloat(maxDuration))) {
      currentErrors += "\n\tmaxDuration (" + maxDuration + ") is not integer ";
      okVals = false;
    }
    else if (minDuration != undefined) {
      if (edgeType === "contingent" &amp;&amp; Number(maxDuration) &lt;= Number(minDuration)) {
        currentErrors += "\n\tmaxDuration (" + maxDuration + ") should be > minDuration (" + minDuration + ")";
        okVals = false;

      }
      else if (edgeType === "normal" &amp;&amp; Number(maxDuration) &lt; Number(minDuration)) {
        currentErrors += "\n\tmaxDuration (" + maxDuration + ") should be >= minDuration (" + minDuration + ")";
        okVals = false;
      }
      else if (edgeType != "normal" &amp;&amp; edgeType != "contingent") {
        currentErrors += "\n\tunknown edgeType (" + edgeType + ")";
        okVals = false;
      }
      else logObj.log += "\n " + nodeName + " maxDuration " + maxDuration + " ";
    }
  }
  if (currentErrors != '') {
    logObj.errors += nodeName + currentErrors + '\n';
  }
  return { minDuration, maxDuration, okVals };
}

/**
 * Check range of [minDuration, maxDuration] of the sequenceFlow elements
 * @param {*} element 
 * @param {*} logObj 
 * @param {*} edgeType 
 * @returns {Object} { minDuration, maxDuration, okVals }
 */
function checkMinMax_sequenceFlow(element, logObj, edgeType) {
  let minDuration = undefined, maxDuration = undefined, okVals = true;
  let currentErrors = '';
  let nodeName = element.nodeName + ' ';
  if (element.attributes.name != undefined) nodeName += element.attributes.name.value.replace(/(\r\n|\n|\r)/gm, " ") + ' ';
  if (element.attributes.id != undefined) nodeName += '\n[' + element.attributes.id.value + '] ';
  logObj.log += "\n " + nodeName + " ";

  if (element.attributes["cstnu:minDuration"] === undefined)
    minDuration = 0;
  else
    minDuration = element.attributes["cstnu:minDuration"].value;

  if (element.attributes["cstnu:maxDuration"] === undefined)
    maxDuration = Infinity;
  else
    maxDuration = element.attributes["cstnu:maxDuration"].value;

  if (okVals) {

    if (minDuration === undefined) {
      minDuration = 0;
    }
    if (isNaN(minDuration)) {
      currentErrors += "\n\tminDuration (" + minDuration + ") is NaN ";
      okVals = false;
    }
    else if (!Number.isInteger(parseFloat(minDuration))) {
      currentErrors += "\n\tminDuration (" + minDuration + ") is not integer ";
      okVals = false;
    }
    else if (edgeType === "contingent" &amp;&amp; Number(minDuration) &lt;= 0) {
      currentErrors += "\n\tminDuration (" + minDuration + ") should be > 0 ";
      okVals = false;
    }
    else if (edgeType === "normal" &amp;&amp; Number(minDuration) &lt; 0) {
      currentErrors += "\n\tminDuration (" + minDuration + ") should be >= 0 ";
      okVals = false;
    }
    else if (edgeType != "normal" &amp;&amp; edgeType != "contingent" &amp;&amp; edgeType != "intertask") {
      currentErrors += "\n\tunknown edgeType (" + edgeType + ")";
      okVals = false;
    }
    else logObj.log += "\n " + nodeName + " minDuration " + minDuration + " ";

    if (maxDuration === undefined) {
      maxDuration = Infinity;
    }
    if (isNaN(maxDuration)) {
      currentErrors += "\n\tmaxDuration (" + maxDuration + ") is NaN ";
      okVals = false;
    }
    else if (maxDuration != Infinity &amp;&amp; !Number.isInteger(parseFloat(maxDuration))) {
      currentErrors += "\n\tmaxDuration (" + maxDuration + ") is not integer ";
      okVals = false;
    }
    else if (minDuration != undefined) {
      if (edgeType === "contingent" &amp;&amp; Number(maxDuration) &lt;= Number(minDuration)) {
        currentErrors += "\n\tmaxDuration (" + maxDuration + ") should be > minDuration (" + minDuration + ")";
        okVals = false;

      }
      else if ((edgeType === "normal" || edgeType === "intertask") &amp;&amp; Number(maxDuration) &lt; Number(minDuration)) {
        currentErrors += "\n\tmaxDuration (" + maxDuration + ") should be >= minDuration (" + minDuration + ")";
        okVals = false;
      }
      else if (edgeType != "normal" &amp;&amp; edgeType != "contingent" &amp;&amp; edgeType != "intertask") {
        currentErrors += "\n\tunknown edgeType (" + edgeType + ")";
        okVals = false;
      }
      else logObj.log += "\n " + nodeName + " maxDuration " + maxDuration + " ";
    }
  }
  if (currentErrors != '') {
    logObj.errors += nodeName + currentErrors + '\n';
  }
  return { minDuration, maxDuration, okVals };
}

/**
 * Check range of [minDuration, maxDuration] of the elements
 * @param {*} element 
 * @param {*} logObj 
 * @param {*} edgeType 
 * @returns {Object} { minDuration, maxDuration, okVals }
 */
function checkMinMax_intertask(element, logObj, edgeType) {
  let minDuration = undefined, maxDuration = undefined, okVals = true;
  let currentErrors = '', nodeName = '';

  if (element.id === undefined) {
    currentErrors += '\nIntertask without Id ';
    okVals = false;
    return { minDuration, maxDuration, okVals };
  }
  else {
    nodeName = element.id + ' ';
  }

  logObj.log += "\n " + nodeName + " ";

  // Get min max values
  if (element.minDuration === undefined)
    minDuration = 0;
  else
    minDuration = element.minDuration;

  if (element.maxDuration === undefined)
    maxDuration = Infinity;
  else
    maxDuration = element.maxDuration;

  // Check values  

  if (minDuration === undefined) {
    minDuration = 0;
  }
  if (isNaN(minDuration)) {
    currentErrors += "\n\tminDuration (" + minDuration + ") is NaN ";
    okVals = false;
  }
  else if (!Number.isInteger(parseFloat(minDuration))) {
    currentErrors += "\n\tminDuration (" + minDuration + ") is not integer ";
    okVals = false;
  }
  else if (edgeType === "contingent" &amp;&amp; Number(minDuration) &lt;= 0) {
    currentErrors += "\n\tminDuration (" + minDuration + ") should be > 0 ";
    okVals = false;
  }
  else if (edgeType === "normal" &amp;&amp; Number(minDuration) &lt; 0) {
    currentErrors += "\n\tminDuration (" + minDuration + ") should be >= 0 ";
    okVals = false;
  }
  else if (edgeType != "normal" &amp;&amp; edgeType != "contingent" &amp;&amp; edgeType != "intertask") {
    currentErrors += "\n\tunknown edgeType (" + edgeType + ")";
    okVals = false;
  }
  else logObj.log += "\n " + nodeName + " minDuration " + minDuration + " ";

  if (maxDuration === undefined) {
    maxDuration = Infinity;
  }
  if (isNaN(maxDuration)) {
    currentErrors += "\n\tmaxDuration (" + maxDuration + ") is NaN ";
    okVals = false;
  }
  else if (maxDuration != Infinity &amp;&amp; !Number.isInteger(parseFloat(maxDuration))) {
    currentErrors += "\n\tmaxDuration (" + maxDuration + ") is not integer ";
    okVals = false;
  }
  else if (minDuration != undefined) {
    if (edgeType === "contingent" &amp;&amp; Number(maxDuration) &lt;= Number(minDuration)) {
      currentErrors += "\n\tmaxDuration (" + maxDuration + ") should be > minDuration (" + minDuration + ")";
      okVals = false;

    }
    else if ((edgeType === "normal" || edgeType === "intertask") &amp;&amp; Number(maxDuration) &lt; Number(minDuration)) {
      currentErrors += "\n\tmaxDuration (" + maxDuration + ") should be >= minDuration (" + minDuration + ")";
      okVals = false;
    }
    else if (edgeType != "normal" &amp;&amp; edgeType != "contingent" &amp;&amp; edgeType != "intertask") {
      currentErrors += "\n\tunknown edgeType (" + edgeType + ")";
      okVals = false;
    }
    else logObj.log += "\n " + nodeName + " maxDuration " + maxDuration + " ";
  }

  if (currentErrors != '') {
    logObj.errors += nodeName + currentErrors + '\n';
  }
  return { minDuration, maxDuration, okVals };
}

/**
 * Get the position of an element in the bpmnPlane
 * @param  {Object} bpmnPlane   XML node corresponding to BPMNPlane. Its children are elements
 * @param  {Object} elementId   Id to look for in bpmnPlane
 * @returns {object}             {x,y} position. If undefined it returns {0,0}
 */
function getXY(bpmnPlane, elementId) {
  let x = 0, y = 0, i = 0;

  for (i = 0; i &lt; bpmnPlane.length; i++) {
    let element = bpmnPlane[i];
    if (element.nodeName === "bpmndi:BPMNShape") {
      if (element.attributes.bpmnElement.value === elementId) {
        x = element.firstElementChild.attributes.x.value;
        y = element.firstElementChild.attributes.y.value;
      }
    }
  }

  if (x === undefined) x = 0;
  if (y === undefined) y = 0;

  return { x, y };
}

/**
 * Check that the Gateway elements contains valid number of 
 * inputs and outputs
 * @param {*} element 
 * @param {*} myObjs 
 * @param {*} myLogObj 
 * @param {*} countObjs 
 * @returns {Boolean}
 */
function checkIfIsGateway_isOK(element, myObjs, myLogObj, countObjs) {

  if (element.nodeName.includes("exclusiveGateway") || element.nodeName.includes("parallelGateway")) {

    // Check incoming and outgoing
    let nIncoming = 0, nOutgoing = 0;
    for (let i = 0; i &lt; element.children.length; i++) {
      let child = element.children[i];
      if (child.tagName.includes("incoming")) {
        nIncoming++;
      }
      else if (child.tagName.includes("outgoing")) {
        nOutgoing++;
      }
    }
    if (element.attributes['cstnu:gatewaySplitJoin'] != undefined) {
      if (element.attributes['cstnu:gatewaySplitJoin'].value.includes('split')) {
        // if split, it should have 1 input and 2 outputs
        if (nIncoming != 1 || nOutgoing != 2) {
          myLogObj.errors += '\n' + element.nodeName + ' invalid number of incoming/outcoming arrows \n';
          countObjs.elementsWithError += 1;
          return false;
        }
        if (element.nodeName.includes("exclusiveGateway")) {
          if (element.attributes['cstnu:proposition'] != undefined) {
            myObjs[element.attributes.id.value].proposition = element.attributes['cstnu:proposition'].value;
          }
          else {
            myLogObj.errors += '\n' + element.nodeName + ' proposition not defined \n';
            countObjs.elementsWithError += 1;
            return false;
          }
          myObjs[element.attributes.id.value].obs = 'split';
        }
      }
      if (element.attributes['cstnu:gatewaySplitJoin'].value.includes('join')) {
        // if join, it should have 2 inputs and 1 output
        if (nIncoming != 2 || nOutgoing != 1) {
          myLogObj.errors += '\n' + element.nodeName + ' invalid number of incoming/outcoming arrows \n';
          countObjs.elementsWithError += 1;
          return false;
        }
        if (element.nodeName.includes("exclusiveGateway")) {
          myObjs[element.attributes.id.value].obs = 'join';
        }
      }
    }
    else {
      myLogObj.errors += '\n' + element.nodeName + ' (' + element.attributes.id.value + '): gatewaySplitJoin not defined \n';
      countObjs.elementsWithError += 1;
      return false;
    }
  }

  return true;

}


/**
 * Create two nodes connected by two edges for one BPMN element
 * @param {Object} params Object with the variables element,  graph,  bpmnPlane,
  edgeType,  myLogObj,  countObjs,  myObjs
 */
function setTwoNodesToEdges(params) {
  let { element, // element to transform
    graph,        // node to add the element transformed
    bpmnPlane,    // xml node witht he x,y position
    edgeType,     // contingent or normal
    elementType,  // TASK, XOR, AND
    myLogObj,     // To report erros and log
    countObjs,    // To count tasks, nodes, edges, nContingents, nObservedProposition,elementsWithError
    myObjs        // Dictionary to match bpmnId:cstnId
  } = params;

  // Check minDuration and maxDuration values
  let tmpObj = checkMinMax(element, myLogObj, edgeType);
  let minD = tmpObj.minDuration;
  let maxD = tmpObj.maxDuration;
  let okVals = tmpObj.okVals;

  //If minD or maxD are not OK, do not create the nodes
  if (!okVals) {
    countObjs.elementsWithError += 1;
    return;
  }
  tmpObj = getXY(bpmnPlane, element.attributes.id.value);
  let x = tmpObj.x;
  let y = tmpObj.y;
  let taskNumber = countObjs.tasks + 1;

  if (element.attributes.id != undefined) {

    if (countObjs[elementType] === undefined)
      countObjs[elementType] = 0
    let elementTypeNumber = countObjs[elementType] + 1;

    myObjs[element.attributes.id.value] = { taskNumber: taskNumber, nodeName: '', name: '', id: '', elementType: elementType, elementTypeNumber: elementTypeNumber, cstnuNodeIds: [], cstnuEdgeIds: [], inputs: [], outputs: [], edgeType: edgeType };
    myObjs[element.attributes.id.value].id = element.attributes.id.value;
    myObjs[element.attributes.id.value].nodeName = element.nodeName;
    if (element.attributes.name != undefined) myObjs[element.attributes.id.value].name = element.attributes.name.value.replace(/(\r\n|\n|\r)/gm, "") + ' ';

    if (!checkIfIsGateway_isOK(element, myObjs, myLogObj, countObjs))
      return;

    let label_l = "⊡";
    if (element.attributes["cstnu:label_l"] != undefined)
      if (element.attributes["cstnu:label_l"].value != '')
        label_l = element.attributes["cstnu:label_l"].value;

    // Nodes
    let node = graph.ele("node", { id: "S_" + elementType + "_" + elementTypeNumber }, "");
    node.ele("data", { key: "x" }, Number(x) + Number(elementTypeNumber) - 25);
    node.ele("data", { key: "y" }, Number(y) + Number(elementTypeNumber));
    node.ele("data", { key: "Label" }, label_l);

    node = graph.ele("node", { id: "E_" + elementType + "_" + elementTypeNumber }, "");
    node.ele("data", { key: "x" }, Number(x) - Number(elementTypeNumber) + 25);
    node.ele("data", { key: "y" }, Number(y) - Number(elementTypeNumber));
    node.ele("data", { key: "Label" }, label_l);

    if (myObjs[element.attributes.id.value].obs) {
      if (myObjs[element.attributes.id.value].obs === 'split') {
        node.ele("data", { key: "Obs" }, element.attributes['cstnu:proposition'].value);
        myObjs[element.attributes.id.value].proposition = element.attributes['cstnu:proposition'].value;
        countObjs.nObservedProposition += 1;
      }
    }
    myObjs[element.attributes.id.value].cstnuNodeIds = ["S_" + elementType + "_" + elementTypeNumber, "E_" + elementType + "_" + elementTypeNumber]

    // Edges
    let edgeId = "S_" + elementType + "_" + elementTypeNumber + "-E_" + elementType + "_" + elementTypeNumber;
    let countOccurrences = '';
    if (myObjs['edges_ids'][edgeId] === undefined) {
      myObjs['edges_ids'][edgeId] = { elementIds: [element.id], occurrences: 1 }

    }
    else {
      countOccurrences = '_' + myObjs['edges_ids'][edgeId].occurrences;
      myObjs['edges_ids'][edgeId].occurrences++;
      myObjs['edges_ids'][edgeId].elementIds.push(element.id);
    }
    edgeId += countOccurrences;

    let edge = graph.ele(
      "edge",
      {
        id: edgeId,
        source: "S_" + elementType + "_" + elementTypeNumber,
        target: "E_" + elementType + "_" + elementTypeNumber,
      },
      ""
    );
    edge.ele("data", { key: "Type" }, edgeType);
    edge.ele("data", { key: "Value" }, maxD);
    myObjs[element.attributes.id.value].cstnuEdgeIds.push(edgeId)

    if (Number(minD) != 0) minD = -Number(minD);

    edgeId = "E_" + elementType + "_" + elementTypeNumber + "-S_" + elementType + "_" + elementTypeNumber;
    countOccurrences = '';
    if (myObjs['edges_ids'][edgeId] === undefined) {
      myObjs['edges_ids'][edgeId] = { elementIds: [element.id], occurrences: 1 }
    }
    else {
      countOccurrences = '_' + myObjs['edges_ids'][edgeId].occurrences;
      myObjs['edges_ids'][edgeId].occurrences++;
      myObjs['edges_ids'][edgeId].elementIds.push(element.id);
    }
    edgeId += countOccurrences;

    edge = graph.ele(
      "edge",
      {
        id: edgeId,
        source: "E_" + elementType + "_" + elementTypeNumber,
        target: "S_" + elementType + "_" + elementTypeNumber,
      },
      ""
    );
    edge.ele("data", { key: "Type" }, edgeType);
    edge.ele("data", { key: "Value" }, minD);
    myObjs[element.attributes.id.value].cstnuEdgeIds.push(edgeId)

    countObjs[elementType] += 1;
    countObjs.tasks += 1;
    countObjs.nodes += 2;
    countObjs.edges += 2;
    if (edgeType === "contingent") countObjs.nContingents += 1;

  }
  else {
    myLogObj.errors += element.nodeName + ' without id \n';
    countObjs.elementsWithError += 1;
  }
}


/**
 * Creates one node for START or END elements
 * @param {*} params 
 */
function createOneNode(params) {
  let { element, // element to transform
    graph,        // node to add the element transformed
    bpmnPlane,    // xml node witht he x,y position
    edgeType,     // contingent or normal
    // elementType,  // TASK, XOR, AND 
    myLogObj,     // To report erros and log
    countObjs,    // To count tasks, nodes, edges, nContingents, nObservedProposition,elementsWithError
    myObjs        // Dictionary to match bpmnId:cstnId
  } = params;

  let tmpObj = getXY(bpmnPlane, element.attributes.id.value);
  let x = tmpObj.x;
  let y = tmpObj.y;

  let taskNumber = countObjs.tasks + 1;

  let nodeLabel = '', elementType = '', elementTypeNumber = '';

  if (element.nodeName.includes("startEvent")) {
    nodeLabel += 'Z'
    elementType = 'START';
    if (countObjs.startEventsTotal > 1) {
      nodeLabel += countObjs.startEvents;
      elementTypeNumber = String(countObjs.startEvents)
      countObjs.startEvents += 1;
    }
  }
  else if (element.nodeName.includes("endEvent")) {
    nodeLabel += 'Ω';
    elementType = 'END';
    if (countObjs.endEventsTotal > 1) {
      nodeLabel += countObjs.endEvents;
      elementTypeNumber = String(countObjs.endEvents)
      countObjs.endEvents += 1;
    }
  }
  else {
    myLogObj.errors += "\n one Node unknown " + element.nodeName;
    return;
  }

  // let elementTypeNumber = countObjs[elementType] + 1;


  if (element.attributes.id != undefined) {
    myObjs[element.attributes.id.value] = { taskNumber: taskNumber, nodeName: '', name: '', id: '', elementType: elementType, elementTypeNumber: elementTypeNumber, idCSTNU: elementType + '_' + elementTypeNumber, cstnuNodeIds: [], inputs: [], outputs: [], edgeType: edgeType };
    myObjs[element.attributes.id.value].id = element.attributes.id.value;
    myObjs[element.attributes.id.value].nodeName = element.nodeName;
    if (element.attributes.name != undefined) myObjs[element.attributes.id.value].name = element.attributes.name.value.replace(/(\r\n|\n|\r)/gm, "") + ' ';

    // Nodes
    let node = graph.ele("node", { id: elementType + '_' + elementTypeNumber }, "");
    node.ele("data", { key: "x" }, Number(x) + Number(elementTypeNumber));
    node.ele("data", { key: "y" }, Number(y) + Number(elementTypeNumber));
    node.ele("data", { key: "Label" }, nodeLabel);

    countObjs.tasks += 1;
    myObjs[element.attributes.id.value].cstnuNodeIds = [elementType + '_' + elementTypeNumber]

  }
  else {
    myLogObj.errors += element.nodeName + ' without id \n';
    countObjs.elementsWithError += 1;
  }
}

/**
 * Create two edges from one sequenceFlow
 * @param {Object} params 
 */
function setTwoEdges_sequenceFlow(params) {
  let { element, // element to transform
    graph,        // node to add the element transformed
    // bpmnPlane,    // xml node witht he x,y position
    edgeType,     // contingent or normal
    myLogObj,     // To report erros and log
    countObjs,    // To count tasks, nodes, edges, nContingents, nObservedProposition,elementsWithError
    myObjs        // Dictionary to match bpmnId:cstnId
  } = params;


  let tmpObj = checkMinMax_sequenceFlow(element, myLogObj, edgeType);
  let minD = tmpObj.minDuration;
  let maxD = tmpObj.maxDuration;
  let okVals = tmpObj.okVals;

  //If minD or maxD are not OK, do not create the edges
  if (!okVals) {
    countObjs.elementsWithError += 1;
    return;
  }
  //Get cstnuId of the connected nodes
  let source = element.attributes.sourceRef.value;
  let target = element.attributes.targetRef.value;
  let sourceTaskId = undefined, targetTaskId = undefined;

  if (myObjs[source] != undefined) {
    if (myObjs[source].elementType === 'START' || myObjs[source].elementType === 'END') {
      sourceTaskId = myObjs[source].elementType + "_" + myObjs[source].elementTypeNumber;
    }
    else {
      sourceTaskId = 'E_' + myObjs[source].elementType + "_" + myObjs[source].elementTypeNumber;
    }

  }
  if (myObjs[target] != undefined) {
    if (myObjs[target].elementType === 'START' || myObjs[target].elementType === 'END') {
      targetTaskId = myObjs[target].elementType + '_' + myObjs[target].elementTypeNumber;
    }
    else {
      targetTaskId = 'S_' + myObjs[target].elementType + '_' + myObjs[target].elementTypeNumber;
    }

  }

  // If they are not there, do not create the edges
  if (targetTaskId === undefined || sourceTaskId === undefined) {

    myLogObj.errors += "\n Edges " + element.nodeName;

    myLogObj.errors += "\n\t sourceId " + source + '(' + sourceTaskId + ')';
    if (sourceTaskId != undefined)
      myLogObj.errors += myObjs[source].name;

    myLogObj.errors += "\n\t targetId " + target + '(' + targetTaskId + ')';
    if (targetTaskId != undefined)
      myLogObj.errors += myObjs[target].name;


    countObjs.elementsWithError += 1;
    return;
  }


  let idArrow = element.attributes.id.value;

  myObjs['arrows'][idArrow] = { id: idArrow, source: source, target: target, cstnuEdgeIds: [], edgeType: edgeType };
  myObjs[source].outputs.push(idArrow);
  myObjs[target].inputs.push(idArrow);

  // Edges
  let edgeId = sourceTaskId + "-" + targetTaskId;
  let countOccurrences = '';
  if (myObjs['edges_ids'][edgeId] === undefined) {
    myObjs['edges_ids'][edgeId] = { occurrences: 1 }
    myObjs['edges_ids'][edgeId] = { elementIds: [element.id], occurrences: 1 }
  }
  else {
    countOccurrences = '_' + myObjs['edges_ids'][edgeId].occurrences;
    myObjs['edges_ids'][edgeId].occurrences++;
    myObjs['edges_ids'][edgeId].elementIds.push(element.id);
  }
  edgeId += countOccurrences;

  let edge = undefined;
  if (maxD != Infinity) { // maxD = '∞';
    edge = graph.ele(
      "edge",
      {
        id: edgeId,
        source: sourceTaskId,
        target: targetTaskId,
      },
      ""
    );
    edge.ele("data", { key: "Type" }, edgeType);
    edge.ele("data", { key: "Value" }, maxD);
    countObjs.edges += 1;
    myObjs['arrows'][idArrow].cstnuEdgeIds.push(edgeId);
  }

  edgeId = targetTaskId + "-" + sourceTaskId;
  countOccurrences = '';
  if (myObjs['edges_ids'][edgeId] === undefined) {
    myObjs['edges_ids'][edgeId] = { elementIds: [element.id], occurrences: 1 };
  }
  else {
    countOccurrences = '_' + myObjs['edges_ids'][edgeId].occurrences;
    myObjs['edges_ids'][edgeId].occurrences++;
    myObjs['edges_ids'][edgeId].elementIds.push(element.id);
  }
  edgeId += countOccurrences;

  edge = graph.ele(
    "edge",
    {
      id: edgeId,
      source: targetTaskId,
      target: sourceTaskId,
    },
    ""
  );

  if (Number(minD) != 0) minD = -Number(minD);
  edge.ele("data", { key: "Type" }, edgeType);
  edge.ele("data", { key: "Value" }, minD);

  countObjs.edges += 1;
  myObjs['arrows'][idArrow].cstnuEdgeIds.push(edgeId);
}

function setTwoEdges_intertask(params) {
  let { element, // element to transform
    graph,        // node to add the element transformed
    edgeType,     // contingent or normal
    myLogObj,     // To report erros and log
    countObjs,    // To count tasks, nodes, edges, nContingents, nObservedProposition,elementsWithError
    myObjs        // Dictionary to match bpmnId:cstnId
  } = params;


  let tmpObj = checkMinMax_intertask(element, myLogObj, edgeType);
  let minD = tmpObj.minDuration;
  let maxD = tmpObj.maxDuration;
  let okVals = tmpObj.okVals;

  //If minD, maxD, or id are not OK, do not create the edges
  if (!okVals) {
    countObjs.elementsWithError += 1;
    return;
  }

  //Get cstnuId of the connected nodes
  let elementId = element.id + ' ';
  let source = element.source;
  let target = element.target;
  let connFrom = element.intertaskConnFrom;
  let connTo = element.intertaskConnTo;
  let sourceTaskId = undefined, targetTaskId = undefined;


  if (myObjs[source] != undefined) {
    if (myObjs[source].type === 'START' || myObjs[source].type === 'END') {
      // Check if this is valid 
    }
    else {
      if (connFrom == undefined || connFrom === 'end')
        sourceTaskId = "E_" + myObjs[source].elementType + "_" + myObjs[source].elementTypeNumber;
      else
        sourceTaskId = "S_" + myObjs[source].elementType + "_" + myObjs[source].elementTypeNumber;
    }

  }
  if (myObjs[target] != undefined) {
    if (myObjs[target].type === 'START' || myObjs[target].type === 'END') {
      // Check if this is valid 
    }
    else {
      if (connTo == undefined || connTo === 'start')
        targetTaskId = "S_" + myObjs[target].elementType + '_' + myObjs[target].elementTypeNumber;
      else
        targetTaskId = "E_" + myObjs[target].elementType + '_' + myObjs[target].elementTypeNumber;
    }

  }

  // If they are not there, do not create the edges
  if (targetTaskId === undefined || sourceTaskId === undefined) {
    myLogObj.errors += "\n Edges " + element.nodeName;

    myLogObj.errors += "\n\t sourceId " + source + '(' + sourceTaskId + ')';
    if (sourceTaskId != undefined)
      myLogObj.errors += myObjs[source].name;

    myLogObj.errors += "\n\t targetId " + target + '(' + targetTaskId + ')';
    if (targetTaskId != undefined)
      myLogObj.errors += myObjs[target].name;

    countObjs.elementsWithError += 1;
    return;
  }

  // Edges
  let edgeId = '';
  let countOccurrences = '';
  let edge = undefined;
  if (maxD != Infinity) { // maxD = '∞';
    edgeId = sourceTaskId + "-" + targetTaskId;
    countOccurrences = '';
    if (myObjs['edges_ids'][edgeId] === undefined) {
      myObjs['edges_ids'][edgeId] = { elementIds: [element.id], occurrences: 1 }
    }
    else {
      countOccurrences = '_' + myObjs['edges_ids'][edgeId].occurrences;
      myObjs['edges_ids'][edgeId].occurrences++;
      myObjs['edges_ids'][edgeId].elementIds.push(element.id);
    }
    edgeId += countOccurrences;
    edge = graph.ele(
      "edge",
      {
        id: edgeId,
        source: sourceTaskId,
        target: targetTaskId,
      },
      ""
    );

    edge.ele("data", { key: "Type" }, 'normal '); //edgeType
    edge.ele("data", { key: "Value" }, maxD);
    countObjs.edges += 1;

  }

  edgeId = targetTaskId + "-" + sourceTaskId;
  countOccurrences = '';
  if (myObjs['edges_ids'][edgeId] === undefined) {
    myObjs['edges_ids'][edgeId] = { elementIds: [element.id], occurrences: 1 }
  }
  else {
    countOccurrences = '_' + myObjs['edges_ids'][edgeId].occurrences;
    myObjs['edges_ids'][edgeId].occurrences++;
    myObjs['edges_ids'][edgeId].elementIds.push(element.id);
  }
  edgeId += countOccurrences;

  edge = graph.ele(
    "edge",
    {
      id: edgeId,
      source: targetTaskId,
      target: sourceTaskId,
    },
    ""
  );

  if (Number(minD) != 0) minD = -Number(minD);
  edge.ele("data", { key: "Type" }, 'normal'); //edgeType
  edge.ele("data", { key: "Value" }, minD);

  countObjs.edges += 1;

}

/**
 * Create root node and descriptive nodes of CSTN XML file
 * @returns {builder.XMLElement} XML root element 
 */
function getStart_xml() {
  // To create the CSTN xml
  let root = builder.create("graphml", { version: "1.0", encoding: "UTF-8" });
  root.att("xmlns", "http://graphml.graphdrawing.org/xmlns/graphml");
  root.att("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
  root.att(
    "xsi:schemaLocation",
    "http://graphml.graphdrawing.org/xmlns/graphml"
  );

  // Elements with description/configuration
  let ele = root.ele("key", { id: "nContingent", for: "graph" });
  ele.ele("desc", {}, "Number of contingents in the graph");
  ele.ele("default", {}, "0");

  ele = root.ele('key', { 'id': 'nObservedProposition', 'for': 'graph' });
  ele.ele('desc', {}, 'Number of observed propositions in the graph');
  ele.ele('default', {}, '0');

  ele = root.ele('key', { 'id': 'NetworkType', 'for': 'graph' });
  ele.ele('desc', {}, 'Network Type');
  ele.ele('default', {}, 'CSTNU');

  ele = root.ele('key', { 'id': 'nEdges', 'for': 'graph' });
  ele.ele('desc', {}, 'Number of edges in the graph');
  ele.ele('default', {}, '0');

  ele = root.ele('key', { 'id': 'nVertices', 'for': 'graph' });
  ele.ele('desc', {}, 'Number of vertices in the graph');
  ele.ele('default', {}, '0');

  ele = root.ele('key', { 'id': 'Name', 'for': 'graph' });
  ele.ele('desc', {}, 'Graph Name');
  ele.ele('default', {}, '');

  ele = root.ele('key', { 'id': 'Obs', 'for': 'node' });
  ele.ele('desc', {}, 'Proposition Observed. Value specification: [a-zA-F]');
  ele.ele('default', {}, '');

  ele = root.ele('key', { 'id': 'x', 'for': 'node' });
  ele.ele('desc', {}, 'The x coordinate for the visualitation. A positive value.');
  ele.ele('default', {}, '0');

  ele = root.ele('key', { 'id': 'Label', 'for': 'node' });
  ele.ele('desc', {}, 'Label. Format: [¬[a-zA-F]|[a-zA-F]]+|⊡');
  ele.ele('default', {}, '⊡');

  ele = root.ele('key', { 'id': 'y', 'for': 'node' });
  ele.ele('desc', {}, 'The y coordinate for the visualitation. A positive value.');
  ele.ele('default', {}, '0');

  ele = root.ele('key', { 'id': 'Potential', 'for': 'node' });
  ele.ele('desc', {}, "Labeled Potential Values. Format: {[('node name (no case modification)', 'integer', 'label') ]+}|{}");
  ele.ele('default', {}, '');

  ele = root.ele('key', { 'id': 'Type', 'for': 'edge' });
  ele.ele('desc', {}, 'Type: Possible values: normal|contingent|constraint|derived|internal.');
  ele.ele('default', {}, 'normal');

  ele = root.ele('key', { 'id': 'LowerCaseLabeledValues', 'for': 'edge' });
  ele.ele('desc', {}, "Labeled Lower-Case Values. Format: {[('node name (no case modification)', 'integer', 'label') ]+}|{}");
  ele.ele('default', {}, '');

  ele = root.ele('key', { 'id': 'UpperCaseLabeledValues', 'for': 'edge' });
  ele.ele('desc', {}, "Labeled Upper-Case Values. Format: {[('node name (no case modification)', 'integer', 'label') ]+}|{}");
  ele.ele('default', {}, '');

  ele = root.ele('key', { 'id': 'Value', 'for': 'edge' });
  ele.ele('desc', {}, "Value for STN edge. Format: 'integer'");
  ele.ele('default', {}, '');

  ele = root.ele('key', { 'id': 'LabeledValues', 'for': 'edge' });
  ele.ele('desc', {}, "Labeled Values. Format: {[('integer', 'label') ]+}|{}");
  ele.ele('default', {}, '');

  return root;
}

/**
 * Get the BPMNPlane from the BPMNDiagram with the elements' positions
 * @param {xmlObject} xmlDoc 
 * @returns bpmnPlane a XML node
 */
function get_bpmnPlane(xmlDoc) {
  let bpmnPlane = undefined;
  let i = 0, j = 0;
  for (i = 0; i &lt; xmlDoc.children[0].children.length; i++) {
    let elementP = xmlDoc.children[0].children[i];
    if (elementP.nodeName.includes("BPMNDiagram")) {
      for (j = 0; j &lt; elementP.children.length; j++) {
        let element = elementP.children[j];
        if (element.nodeName.includes("BPMNPlane")) {
          bpmnPlane = element.children;
        }
      };
    }
  };
  return bpmnPlane;
}
/**
 * Iterates all the BPMN elements of xmlDoc and 
 * creates the corresponding CSTNU elements
 * @param {xmlDocument} xmlDoc 
 * @param {xmlNode} bpmnPlane 
 * @param {xmlNode} graph 
 * @param {Object} myLogObj 
 * @param {Object} countObjs 
 * @param {Object} myObjs 
 */
function setElements(xmlDoc, bpmnPlane, graph, myLogObj, countObjs, myObjs, customElements) {
  let i = 0, j = 0;

  for (i = 0; i &lt; xmlDoc.children[0].children.length; i++) {
    let elementP = xmlDoc.children[0].children[i];
    if (elementP.nodeName.includes("process")) {
      for (j = 0; j &lt; elementP.children.length; j++) {
        let element = elementP.children[j];
        let paramsContingent = { elementType: 'TASK', element, graph, bpmnPlane, "edgeType": "contingent", myLogObj, countObjs, myObjs };
        let paramsNormal = { elementType: 'TASK', element, graph, bpmnPlane, "edgeType": "normal", myLogObj, countObjs, myObjs };
        let elementName = element.nodeName; //.toLowerCase()           
        // ---------------- Tasks --------------- //            
        if (elementName.includes("task")) {
          // console.log(elementName + " not allowed");
          myLogObj.warnings += "\n " + elementName + " " + " not allowed \n "; // +element.attributes.id 
          countObjs.elementsWithWarning++;
        }
        else if (elementName.includes("userTask")) {
          setTwoNodesToEdges(paramsContingent);
        }
        else if (elementName.includes("serviceTask")) {
          setTwoNodesToEdges(paramsContingent);
        }
        else if (elementName.includes("scriptTask")) {
          setTwoNodesToEdges(paramsNormal);
        }
        else if (elementName.includes("sendTask")) {
          setTwoNodesToEdges(paramsContingent);
        }
        else if (elementName.includes("receiveTask")) {
          setTwoNodesToEdges(paramsContingent);
        }
        else if (elementName.includes("subProcess")) {
          setTwoNodesToEdges(paramsContingent);
        }
        //  ---------------------- Events ---------------//
        else if (elementName.includes("intermediateCatchEvent")) {
          // Subtypes are
          //  bpmn:timerEventDefinition   // This is a bit different TODO
          //  bpmn:messageEventDefinition
          //  bpnm:singleEventDefinition
          // debugger;
          setTwoNodesToEdges(paramsNormal);
          // setTwoNodesToEdges(paramsContingent);
        }
        else if (elementName.includes("boundaryEvent")) {
          // console.log(elementName + " not now");
          myLogObj.warnings += "\n" + elementName + " no processed";
          countObjs.elementsWithWarning++;
        }
        else if (elementName.includes("startEvent")) {
          //Need to know how many to decide Z or Z_i
          countObjs.startEventsTotal += 1;
        }
        else if (elementName.includes("endEvent")) {
          //Need to know how many to decide Omega or Omega_i
          countObjs.endEventsTotal += 1;
        }
        // ---------------------------- SequenceFlow -------------------------//
        else if (elementName.includes("sequenceFlow")) {
          // This will be processed later                
        }
        // ----------- Gateways -------------------//
        else if (elementName.includes("parallelGateway")) {
          paramsNormal.elementType = 'AND';
          setTwoNodesToEdges(paramsNormal);
        }
        else if (elementName.includes("exclusiveGateway")) {
          paramsNormal.elementType = 'XOR';
          setTwoNodesToEdges(paramsNormal);
        }
        else if (elementName.includes("eventBasedGateway")) {
          paramsNormal.elementType = 'GATEWAY';
          setTwoNodesToEdges(paramsNormal);
        }
        // Non considerated    
        else {
          myLogObj.warnings += "\n" + elementName + " no processed";
          countObjs.elementsWithWarning++;
        }
      }
    }
  }
  for (i = 0; i &lt; xmlDoc.children[0].children.length; i++) {
    let elementP = xmlDoc.children[0].children[i];
    if (elementP.nodeName.includes("process")) {
      // startEvent and endEvet
      for (j = 0; j &lt; elementP.children.length; j++) {
        let element = elementP.children[j];
        let paramsNormal = { element, graph, bpmnPlane, "edgeType": "normal", myLogObj, countObjs, myObjs };
        let elementName = element.nodeName;
        // ---------------------------- startEvent and endEvet -------------------------//
        if (elementName.includes("startEvent")) {
          createOneNode(paramsNormal);
        }
        else if (elementName.includes("endEvent")) {
          createOneNode(paramsNormal);
        }
      }
    }
  }

  for (i = 0; i &lt; xmlDoc.children[0].children.length; i++) {
    let elementP = xmlDoc.children[0].children[i];
    if (elementP.nodeName.includes("process")) {
      // sequenceFlow processed once all the elments were processed
      for (j = 0; j &lt; elementP.children.length; j++) {
        let element = elementP.children[j];
        let paramsNormal = { element, graph, bpmnPlane, "edgeType": "normal", myLogObj, countObjs, myObjs };
        let elementName = element.nodeName;
        // ---------------------------- SequenceFlow -------------------------//
        if (elementName.includes("sequenceFlow")) {
          setTwoEdges_sequenceFlow(paramsNormal);
        }

      }
    }
  }
  // Intertasks 
  for (i = 0; i &lt; customElements.length; i++) {
    let element = customElements[i];
    let paramsIntertask = { element, graph, bpmnPlane, "edgeType": "intertask", myLogObj, countObjs, myObjs };
    setTwoEdges_intertask(paramsIntertask);
  }
  //debugger;  
  //Check edges 
  let keys = Object.keys(myObjs['edges_ids']);
  keys.forEach(edge => {

    // console.log(edge);
    if (myObjs['edges_ids'][edge].occurrences > 1) {
      myLogObj.errors += 'Edge ' + edge + ' duplicated. Elements: ' + myObjs['edges_ids'][edge].elementIds;
      countObjs.elementsWithError += 1;
    }
  });

}

/**
 * Get the nodeName of a node of type process
 * @param {xmlDocument} xmlDoc 
 * @returns {String} 
 */
function getProcessName(xmlDoc) {
  let name = "", i = 0;

  for (i = 0; i &lt; xmlDoc.children[0].children.length; i++) {
    let elementP = xmlDoc.children[0].children[i];
    if (elementP.nodeName.includes("process")) {
      name = elementP.attributes.name.value;
    }
  }
  return name;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-serverNodeJs.html">serverNodeJs</a></li><li><a href="module-temporal-plugins-client.html">temporal-plugins-client</a></li><li><a href="module-temporal-plugins-client_CSTNU.html">temporal-plugins-client/CSTNU</a></li><li><a href="module-temporal-plugins-client_CSTNU_bpmn2cstnu.html">temporal-plugins-client/CSTNU/bpmn2cstnu</a></li><li><a href="module-temporal-plugins-client_CSTNU_bpmnSetcstnuLabels.html">temporal-plugins-client/CSTNU/bpmnSetcstnuLabels</a></li><li><a href="module-temporal-plugins-client_CSTNU_cstnuChecked.html">temporal-plugins-client/CSTNU/cstnuChecked</a></li><li><a href="module-temporal-plugins-server.html">temporal-plugins-server</a></li><li><a href="module-temporal-plugins-server_CSTNU.html">temporal-plugins-server/CSTNU</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sun Jul 25 2021 22:02:42 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
